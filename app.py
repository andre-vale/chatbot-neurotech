# -*- coding: utf-8 -*-
"""Desafio_Chatbot_3_Implementando_Chatbot.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hkNYpne-p2xYK4DirdHYky7zTaY8v975

### Instalando o flask
"""

#pip install flask transformers psycopg2 pandas

#pip install sqlalchemy

from flask import Flask, request, jsonify, render_template_string
from transformers import AutoTokenizer, AutoModelForMaskedLM
from sqlalchemy import create_engine
import psycopg2
import pandas as pd

# Configuração do Flask
app = Flask(__name__)

"""### Conexão com o Banco de Dados"""

# Configurações do Banco de Dados RDS
db_config = {
    "host": "chatbotdb.cz0yqgoeikkw.us-east-2.rds.amazonaws.com",
    "database": "postgres",
    "user": "postgres",
    "password": "Erdnal31#",
    "port": 5432
}

# Conexão com o RDS PostgreSQL (primeira tentativa usando pandas não deu certo. o método read_sql deu muito erro. tentativa 2 usando SQLAlchemy)
def connect_rds():
    # try:
    #     conn = psycopg2.connect(
    #         host=db_config["host"],
    #         database=db_config["database"],
    #         user=db_config["user"],
    #         password=db_config["password"],
    #         port=db_config["port"]
    #     )
    #     print("Conexão bem-sucedida ao RDS!")
    #     return conn
    # except Exception as e:
    #     print("Erro ao conectar ao banco de dados:", e)
    #     return None

    try:
        conn = (
            f"postgresql+psycopg2://{db_config['user']}:{db_config['password']}@"
            f"{db_config['host']}:{db_config['port']}/{db_config['database']}"
        )
        #Corrected indentation - these lines should be indented 4 spaces from the try block
        engine = create_engine(conn)
        print("Conexão bem-sucedida ao RDS via SQLAlchemy!")
        return engine
    except Exception as e:
        print("Erro ao conectar ao banco de dados:", e)
        return None

"""### Carregar o modelo BERTimbau"""

# Carregar modelo BERTimbau
model_name = "neuralmind/bert-base-portuguese-cased"
tokenizer = AutoTokenizer.from_pretrained(model_name)
model = AutoModelForMaskedLM.from_pretrained(model_name)

"""### Processar e Tokenizar a consulta do usuário"""

# Função para processar a consulta do usuário
def process_query(question):
    # Identificar palavras-chave na pergunta
    keywords = {
        "média": "AVG",
        "inadimplência": "TARGET = 1",
        "UF": "VAR5",
        "idade": "IDADE",
    }

    # Tokenizar a pergunta
    tokens = tokenizer.tokenize(question.lower())

    # Criar a query SQL com base nas palavras-chave identificadas
    sql_query = "SELECT "
    if "média" in tokens and "idade" in tokens:
        sql_query += "VAR5, AVG(IDADE) AS media_idade FROM chatbot_data2 GROUP BY VAR5;"
    elif "inadimplência" in tokens:
        sql_query += "VAR5, COUNT(*) AS qtd_inadimplentes FROM chatbot_data2 WHERE TARGET = 1 GROUP BY VAR5;"
    else:
        return None

    return sql_query

"""### Configurando a interface com Flask




"""

# Página inicial para o chatbot
@app.route("/")
def index():
    return render_template_string("""
        <!doctype html>
        <title>Chatbot de Análise de Dados</title>
        <h1>Faça sua pergunta sobre o dataset!</h1>
        <form action="/query" method="post">
          Pergunta: <input type="text" name="question">
          <input type="submit" value="Enviar">
        </form>
    """)

from sqlalchemy.sql import text

@app.route("/query", methods=["POST"])
def query():
    if request.content_type == "application/json":
        question = request.json.get("question")
    else:
        question = request.form.get("question")

    if not question:
        return jsonify({"error": "Por favor, forneça uma pergunta válida."}), 400

    sql_query = process_query(question)
    if not sql_query:
        return jsonify({"error": "Não consegui entender sua pergunta. Tente reformular."}), 400

    engine = connect_rds()
    if not engine:
        return jsonify({"error": "Erro ao conectar ao banco de dados."}), 500

    try:
        with engine.connect() as conn:
            # Use o objeto `text` para executar a query
            result = conn.execute(text(sql_query))
            data = result.fetchall()

            # Transformar os resultados em um DataFrame (opcional)
            columns = result.keys()
            df = pd.DataFrame(data, columns=columns)

            # Retornar a resposta formatada
            if "media_idade" in df.columns:
                response = "A média de idade por UF é:\n" + "\n".join(
                    [f"{row['var5']}: {row['media_idade']:.1f} anos" for _, row in df.iterrows()]
                )
            else:
                response = "Consulta realizada com sucesso, mas não há dados para exibir."

            return jsonify({"response": response})
    except Exception as e:
        print(f"Erro ao executar a query: {str(e)}")
        return jsonify({"error": f"Erro ao executar a query: {str(e)}"}), 500

# Endpoint para retornar resultados processados
@app.route("/results", methods=["GET"])
def results():
    return jsonify({"message": "Este endpoint será usado para resultados processados!"})

# Iniciar o servidor Flask
if __name__ == "__main__":
    app.run(debug=True)